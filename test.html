<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Globe with Country Outlines and OrbitControls</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene, camera, and renderer setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


        // Camera position
        camera.position.z = 200;


        // OrbitControls setup
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;


        // Add a transparent black globe
        const globeRadius = 100;
        const globeGeometry = new THREE.SphereGeometry(globeRadius, 64, 64);
        const globeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x000000, 
            transparent: true, 
            opacity: 0.3 
        });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);


        // Create starfield
        function createStarfield(numStars, distance) {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.5, 
                sizeAttenuation: true 
            });
            const starVertices = [];
            for (let i = 0; i < numStars; i++) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = distance + (Math.random() * 50);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        createStarfield(1000, 300); // 1000 stars at distance 300


        // Convert GeoJSON coordinates to spherical coordinates
        function toSphericalCoords(lng, lat, radius) {
            const phi = (90 - lat) * Math.PI / 180; // Latitude to polar angle
            const theta = (-lng + 180) * Math.PI / 180; // Negate longitude to fix mirroring
            return new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }


        // Function to draw lines from GeoJSON coordinates
        function drawLines(coordinates, radius) {
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff, // White color
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });


            coordinates.forEach(ring => {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                ring.forEach(coord => {
                    const vertex = toSphericalCoords(coord[0], coord[1], radius);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                });
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const line = new THREE.Line(geometry, material);
                scene.add(line);
            });
        }


        // Process GeoJSON data
        function processGeoJSON(geojson) {
            geojson.features.forEach(feature => {
                const geom = feature.geometry;
                if (geom.type === 'Polygon') {
                    drawLines(geom.coordinates, globeRadius);
                } else if (geom.type === 'MultiPolygon') {
                    geom.coordinates.forEach(polygon => {
                        drawLines(polygon, globeRadius);
                    });
                }
            });
        }


        // Load GeoJSON data
        fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json')
            .then(response => response.json())
            .then(data => {
                processGeoJSON(data);
            })
            .catch(err => console.error('Error loading GeoJSON:', err));


        // Auto-rotation logic
        let isUserInteracting = false;
        let rotationSpeed = 0.005;


        controls.addEventListener('start', () => {
            isUserInteracting = true;
        });


        controls.addEventListener('end', () => {
            isUserInteracting = false;
        });


        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (!isUserInteracting) {
                globe.rotation.y += rotationSpeed; // Auto-rotate when not interacting
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();


        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
