<div class='container boxed-container'>
  <h1>Asset Tracker - Global Network Visualization</h1>
  <p>An ultra-fast, GPU-powered interactive globe demonstrating asset network coverage and real-time geographic data processing.</p>
  
  <div class="globe-view-full">
    <div id="ui">
        <input id="search" type="text" placeholder="Type a country (e.g., Canada) …" spellcheck="false" />
        <div id="info">Hover a country</div>
    </div>
    <div id="hint">Drag to rotate • Scroll to zoom</div>
    <div id="app">
        </div>
  </div>
</div>

<style>
.boxed-container {
    max-width: 1000px;
    margin: 20px auto;
    padding: 20px;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.globe-view-full {
    position: relative;
    /* Use the same fixed size as the viewport in the original code for initial setup */
    width: 960px;
    height: 600px; 
    margin: 20px auto 0;
    border: 1px solid #ddd;
    border-radius: 6px;
    overflow: hidden;
    background-color: #030308;
}

/* Three.js canvas styling */
#app {
    width: 100%;
    height: 100%;
    cursor: grab; /* Set drag cursor */
}

/* UI/INFO/HINT LAYOUT (Absolute positioned over the canvas) */
#ui, #hint {
    position: absolute;
    z-index: 10;
    pointer-events: none; /* Allows mouse events to pass through to the canvas */
}

#ui {
    top: 10px;
    left: 10px;
    pointer-events: auto; /* Re-enable for the UI elements themselves */
    display: flex;
    flex-direction: column;
    gap: 5px;
}
#info {
    padding: 5px 10px;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
    border-radius: 4px;
    font-size: 0.9em;
    font-family: sans-serif;
}
#search {
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    font-size: 1em;
}

#hint {
    bottom: 10px;
    right: 10px;
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.8em;
}
</style>

<script>
// NOTE: This entire script relies on THREE and THREE.OrbitControls being loaded 
// globally by <script> tags in your main index.html file.

// --- JSON Data Location (MUST BE UPDATED TO YOUR ACTUAL PATH) ---
const COUNTRIES_JSON_PATH = 'countries-110m.json'; 
// If your file is in an assets folder, change to: 'assets/countries-110m.json'

let renderer, scene, camera, controls, sphere, dataSphere, ring;
let idToName = new Map();
let nameToId = new Map();
let pickingSphere = null;

/* -----------------------------
    Math helpers
-------------------------------- */
const TAU = Math.PI * 2;
const toRad = d => d * Math.PI / 180;
const lonLatToUV = (lon, lat) => {
    const u = (lon + 180) / 360;
    const v = (90 - lat) / 180;
    return [u, v];
};
const vec3FromLonLat = (lonDeg, latDeg, r = 1) => {
    const lon = toRad(lonDeg);
    const lat = toRad(latDeg);
    const x = r * Math.cos(lat) * Math.sin(lon);
    const y = r * Math.sin(lat);
    const z = r * Math.cos(lat) * Math.cos(lon);
    return new THREE.Vector3(x, y, z);
};
const idToRGB = id => {
    const r = (id >> 16) & 255, g = (id >> 8) & 255, b = id & 255;
    return `rgb(${r},${g},${b})`;
};
const rgbToId = (r, g, b) => (r << 16) | (g << 8) | b;


/* -----------------------------
    Main Initialization Function
-------------------------------- */

// Wrapper to ensure canvas and THREE are ready
function startAssetTrackerGlobe() {
    const appEl = document.getElementById('app');
    // Check for canvas parent and global libraries before running init
    if (appEl && typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') {
        try {
            console.log("THREE.js libraries are loaded. Starting globe setup...");
            init();
            loadWorldData(); // Start the asynchronous data loading
            (function loop() {
                const time = clock.getElapsedTime();
                dataSphere.material.uniforms.uTime.value = time;
                ring.material.uniforms.uTime.value = time;
                if (needsRender) {
                    controls.update();
                    renderer.render(scene, camera);
                    needsRender = false;
                }
                requestAnimationFrame(loop);
            })();
        } catch (e) {
            console.error("Critical: THREE.js initialization failed.", e);
        }
    } else {
        // Retry later if libraries or container are not ready
        setTimeout(startAssetTrackerGlobe, 100);
    }
}


function init() {
    const appEl = document.getElementById('app');
    if (!appEl) return;

    // Use current element dimensions
    const VIEW_WIDTH = appEl.clientWidth;
    const VIEW_HEIGHT = appEl.clientHeight; 

    // Scene / Renderer / Camera Setup (Original code adapted to globals)
    renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
    renderer.setPixelRatio(Math.min(1.25, window.devicePixelRatio));
    renderer.setSize(VIEW_WIDTH, VIEW_HEIGHT);
    appEl.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color('#030308');

    camera = new THREE.PerspectiveCamera(45, VIEW_WIDTH / VIEW_HEIGHT, 0.1, 1000);
    camera.position.set(0, 0, 3.2);
    camera.lookAt(0, 0, 0);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.9;
    controls.zoomSpeed = 0.7;
    controls.minDistance = 1.6;
    controls.maxDistance = 6;
    controls.enablePan = false;
    controls.addEventListener('change', requestRender);

    scene.add(new THREE.AmbientLight(0xffffff, 0.2));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5, 3, 5);
    scene.add(dir);
    
    // Country ID canvas / Textures
    const W = 4096, H = 2048;
    const idCanvas = document.createElement('canvas');
    idCanvas.width = W; idCanvas.height = H;
    idCtx = idCanvas.getContext('2d', { willReadFrequently: true });

    const outlineCanvas = document.createElement('canvas');
    outlineCanvas.width = W; outlineCanvas.height = H;
    outlineCtx = outlineCanvas.getContext('2d');
    
    // Create textures (they will be updated later)
    idTexture = new THREE.CanvasTexture(idCanvas);
    idTexture.minFilter = THREE.NearestFilter;
    idTexture.magFilter = THREE.NearestFilter;
    idTexture.generateMipmaps = false;

    outlineTexture = new THREE.CanvasTexture(outlineCanvas);
    outlineTexture.minFilter = THREE.LinearFilter;
    outlineTexture.magFilter = THREE.LinearFilter;
    outlineTexture.generateMipmaps = false;

    // Globe Mesh (MUST use the textures created above)
    sphere = new THREE.Mesh(
        new THREE.SphereGeometry(1, 128, 64),
        new THREE.ShaderMaterial({
            uniforms: {
                uIdTex: { value: idTexture }, // NOW EXISTS
                uOutlineTex: { value: outlineTexture }, // NOW EXISTS
                uSelectedId: { value: 0 },
                uBaseColor: { value: new THREE.Color('#0d1222') }, 
                uLandColor: { value: new THREE.Color('#1f335b') }, 
                uHoverColor: { value: new THREE.Color('#ffde8e') }, 
                uShowOutline: { value: 1 }
            },
            // ... (your existing vertex/fragment shaders for sphere) ...
             vertexShader: `
                varying vec2 vUv;
                void main(){
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                precision mediump float;
                uniform sampler2D uIdTex;
                uniform sampler2D uOutlineTex;
                uniform vec3 uBaseColor, uLandColor, uHoverColor;
                uniform int uSelectedId;
                uniform int uShowOutline;
                varying vec2 vUv;
                void main(){
                    vec3 idRGB = texture2D(uIdTex, vUv).rgb;
                    int id = int(floor(idRGB.r*255.0))*65536 + int(floor(idRGB.g*255.0))*256 + int(floor(idRGB.b*255.0));
                    vec3 color = uBaseColor;
                    if (id != 0) {
                        color = uLandColor;
                        if (id == uSelectedId) color = mix(uLandColor, uHoverColor, 0.75);
                    }
                    if (uShowOutline == 1) {
                        float edge = texture2D(uOutlineTex, vUv).r;
                        color = mix(color, vec3(0.5, 0.8, 1.0), edge * 1.0); // Brighter outline
                    }
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        })
    );
    scene.add(sphere);

    // Data Sphere (Points/Glow layer)
    dataSphere = new THREE.Mesh(
        new THREE.SphereGeometry(1.002, 128, 64),
        new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uDataTex: { value: null } },
            // ... (your existing vertex/fragment shaders for dataSphere) ...
             vertexShader: `
                varying vec2 vUv;
                void main(){
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                precision mediump float;
                uniform float uTime;
                varying vec2 vUv;
                
                // Simple hash function for procedural noise
                vec2 hash22(vec2 p){
                    p = fract(p * vec2(5.3983, 5.257));
                    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));
                    return fract(p) - 0.5;
                }
                
                void main() {
                    vec2 p = vUv * 12.0;
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    
                    vec2 a = hash22(i + vec2(0,0));
                    vec2 b = hash22(i + vec2(1,0));
                    vec2 c = hash22(i + vec2(0,1));
                    vec2 d = hash22(i + vec2(1,1));
                    
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    
                    float n = mix(mix(dot(a,f - vec2(0,0)), dot(b,f - vec2(1,0)), u.x),
                                    mix(dot(c,f - vec2(0,1)), dot(d,f - vec2(1,1)), u.x), u.y);

                    float glow = sin(n * 2.0 + uTime * 0.5) * 0.5 + 0.5;
                    glow = pow(glow, 20.0);
                    
                    vec3 color = vec3(0.1, 0.8, 1.0) * glow;
                    gl_FragColor = vec4(color, glow * 0.8);
                }
            `,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false
        })
    );
    scene.add(dataSphere);

    // Pulsing Ring
    ring = new THREE.Mesh(
        new THREE.TorusGeometry(1.2, 0.005, 16, 100),
        new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            // ... (your existing vertex/fragment shaders for ring) ...
            vertexShader: `
                varying vec2 vUv;
                void main(){
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                precision mediump float;
                uniform float uTime;
                varying vec2 vUv;
                
                void main() {
                    float pulse = sin(uTime * 1.5) * 0.5 + 0.5;
                    float opacity = pow(pulse, 5.0);
                    vec3 color = vec3(0.3, 0.9, 1.0);
                    gl_FragColor = vec4(color, opacity);
                }
            `,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false
        })
    );
    ring.rotation.x = Math.PI / 2;
    scene.add(ring);
    
    // Global event listeners
    window.addEventListener('resize', () => {
        const parent = appEl.parentElement;
        renderer.setSize(parent.clientWidth, parent.clientHeight);
        camera.aspect = parent.clientWidth / parent.clientHeight;
        camera.updateProjectionMatrix();
        pickingTexture.setSize(parent.clientWidth, parent.clientHeight);
        requestRender();
    });
}

/* -----------------------------
    Data Loading and Rasterization (Adapted for standard fetch)
-------------------------------- */
let idCtx, outlineCtx, idTexture, outlineTexture;
const W = 4096, H = 2048; 

function loadWorldData() {
    fetch(COUNTRIES_JSON_PATH)
        .then(r => {
             if (!r.ok) {
                console.error(`Failed to load ${COUNTRIES_JSON_PATH}: ${r.status}`);
                return null;
            }
            return r.json();
        })
        .then(world => {
            if (!world) return;
            console.log("World data loaded. Rasterizing...");
            const { transform, arcs, objects } = world;
            const scale = transform.scale, translate = transform.translate;

            function decodeArc(i) {
                const arc = arcs[i < 0 ? ~i : i];
                let x = 0, y = 0;
                const pts = [];
                for (const [dx, dy] of arc) {
                    x += dx; y += dy;
                    const lon = x * scale[0] + translate[0];
                    const lat = y * scale[1] + translate[1];
                    pts.push([lon, lat]);
                }
                return i < 0 ? pts.reverse() : pts;
            }
            function decodeGeometry(geom) {
                if (geom.type === 'Polygon') return [geom.arcs.map(ring => ring.flatMap(decodeArc))];
                if (geom.type === 'MultiPolygon') return geom.arcs.map(poly => poly.map(ring => ring.flatMap(decodeArc)));
                return [];
            }

            const geoms = objects.countries.geometries;

            idCtx.clearRect(0, 0, W, H);
            outlineCtx.clearRect(0, 0, W, H);
            outlineCtx.strokeStyle = '#ffffff';
            outlineCtx.lineWidth = 0.8;

            geoms.forEach((g, idx) => {
                const id = idx + 1;
                const name = g.properties?.name || g.properties?.admin || `#${id}`;
                idToName.set(id, name);
                nameToId.set(name.toLowerCase(), id);

                const polys = decodeGeometry(g);

                idCtx.fillStyle = idToRGB(id);
                idCtx.beginPath();
                polys.forEach(rings => {
                    rings.forEach(ring => {
                        ring.forEach(([lon, lat], k) => {
                            const [u, v] = lonLatToUV(lon, lat);
                            const x = Math.round(u * W), y = Math.round(v * H);
                            if (k === 0) idCtx.moveTo(x, y); else idCtx.lineTo(x, y);
                        });
                        idCtx.closePath();
                    });
                });
                idCtx.fill('evenodd');

                outlineCtx.beginPath();
                polys.forEach(rings => {
                    rings.forEach(ring => {
                        ring.forEach(([lon, lat], k) => {
                            const [u, v] = lonLatToUV(lon, lat);
                            const x = Math.round(u * W), y = Math.round(v * H);
                            if (k === 0) outlineCtx.moveTo(x, y); else outlineCtx.lineTo(x, y);
                        });
                    });
                });
                outlineCtx.stroke();
            });

            idTexture.needsUpdate = true;
            outlineTexture.needsUpdate = true;
            setupPicking();
            requestRender();
            setupSearch();
        });
}

/* -----------------------------
    GPU-based Picking Setup (Rest of your original code)
-------------------------------- */
const pickingTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
const pickingScene = new THREE.Scene();
let pickingCamera; // Defined below
const pickingMaterial = new THREE.ShaderMaterial({
    uniforms: { uIdTex: { value: null } }, // Will be set in setupPicking
    vertexShader: `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        precision mediump float;
        uniform sampler2D uIdTex;
        varying vec2 vUv;
        void main(){
            gl_FragColor = texture2D(uIdTex, vUv);
        }
    `
});

const pixelBuffer = new Uint8Array(4);
let lastHoverId = 0;
let lastRenderTime = 0;
const renderInterval = 16;

function setupPicking() {
    pickingCamera = camera.clone(); // Clone after camera is initialized
    pickingSphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 64), pickingMaterial);
    pickingMaterial.uniforms.uIdTex.value = idTexture;
    pickingScene.add(pickingSphere);
}

function handleMouseMove(e) {
    if (!renderer || !pickingSphere) return;

    const now = performance.now();
    if (now - lastRenderTime < renderInterval) {
        return;
    }
    lastRenderTime = now;

    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    pickingCamera.position.copy(camera.position);
    pickingCamera.quaternion.copy(camera.quaternion);
    pickingCamera.updateMatrixWorld();

    renderer.setRenderTarget(pickingTexture);
    renderer.render(pickingScene, pickingCamera);
    renderer.setRenderTarget(null);

    const x = Math.round((e.clientX - rect.left) * window.devicePixelRatio);
    const y = Math.round((rect.height - (e.clientY - rect.top)) * window.devicePixelRatio);
    renderer.readRenderTargetPixels(pickingTexture, x, y, 1, 1, pixelBuffer);

    const id = rgbToId(pixelBuffer[0], pixelBuffer[1], pixelBuffer[2]);

    if (id !== lastHoverId) {
        lastHoverId = id;
        const mat = sphere.material;
        mat.uniforms.uSelectedId.value = id;
        const infoEl = document.getElementById('info');
        if (infoEl) infoEl.textContent = id === 0 ? 'Ocean' : (idToName.get(id) || 'Unknown');
        requestRender();
    }
}
document.addEventListener('mousemove', handleMouseMove, { passive: true });

/* -----------------------------
    Search fly-to (Adapted to call only after data load)
-------------------------------- */
function setupSearch() {
    const searchEl = document.getElementById('search');
    if (searchEl) {
        searchEl.addEventListener('input', () => {
            const q = searchEl.value.trim().toLowerCase();
            if (!q) return;
            for (const [name, id] of nameToId) {
                if (name.includes(q)) {
                    flyToCountry(id);
                    break;
                }
            }
        });
    }
}

function flyToCountry(id) {
    const center = estimateCentroidFromId(id);
    if (!center) return;
    const [lon, lat] = center;

    const radius = camera.position.length();
    const targetPos = vec3FromLonLat(lon, lat, radius);

    const start = camera.position.clone();
    const end = targetPos.clone();
    const qStart = new THREE.Quaternion().setFromUnitVectors(start.clone().normalize(), end.clone().normalize());
    const t0 = performance.now(), dur = 900;

    const animate = () => {
        const t = Math.min(1, (performance.now() - t0) / dur);
        // Simplified slerp to avoid complex target calculation
        const currentPos = start.clone().slerp(end, t); 
        camera.position.copy(currentPos);
        camera.lookAt(0, 0, 0);
        requestRender();
        if (t < 1) requestAnimationFrame(animate);
    };
    animate();

    sphere.material.uniforms.uSelectedId.value = id;
    requestRender();
}

function estimateCentroidFromId(id) {
    const stepX = 4, stepY = 4;
    let sumLon = 0, sumLat = 0, n = 0;
    // NOTE: Requires idCtx to be available and rasterized
    const data = idCtx.getImageData(0, 0, W, H).data;
    for (let y = 0; y < H; y += stepY) {
        for (let x = 0; x < W; x += stepX) {
            const i = (y * W + x) * 4;
            const pid = rgbToId(data[i], data[i + 1], data[i + 2]);
            if (pid === id) {
                const lon = x / W * 360 - 180;
                const lat = 90 - y / H * 180;
                sumLon += lon; sumLat += lat; n++;
            }
        }
    }
    if (!n) return null;
    return [sumLon / n, sumLat / n];
}

/* -----------------------------
    Render-on-demand loop
-------------------------------- */
let needsRender = true;
function requestRender() { needsRender = true; }
const clock = new THREE.Clock();


// Call the main setup function to start the check loop
startAssetTrackerGlobe();
</script>